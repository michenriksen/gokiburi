package runner

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/aidarkhanov/nanoid/v2"
	"github.com/charmbracelet/log"

	"github.com/michenriksen/gokiburi/internal/pkg/command"
)

const (
	logKeyLineNum = "lineNum"
	logKeyErr     = "error"

	defaultCovermode = "atomic"
	defaultTimeout   = 10 * time.Minute
	defaultGoBin     = "go"

	coverDirPerm = 0o755
)

// Result of a `go test` run.
type Result struct {
	UUID     string        `json:"uuid"`
	Error    string        `json:"error"`
	Pass     bool          `json:"pass"`
	Start    time.Time     `json:"start"`
	Duration time.Duration `json:"duration"`
	ExitCode int           `json:"exitCode"`
	Targets  []string      `json:"targets"`
	Passed   int           `json:"passed"`
	Failed   int           `json:"failed"`
	Skipped  int           `json:"skipped"`
	Tests    int           `json:"tests"`
	Packages []*Package    `json:"packages"`
	dir      string
}

// Close Result.
//
// Deletes the associated coverage directory if it exists.
func (r *Result) Close() error {
	if r.dir == "" {
		return nil
	}

	if err := os.RemoveAll(r.dir); err != nil {
		return fmt.Errorf("deleting test result directory %q: %w", r.dir, err)
	}

	r.dir = ""

	return nil
}

// Dir containing files relevant for the test result.
//
// Directory contains `coverprofile.out` generated by [Runner.Run] as well
// as `report.json` which is a code coverage report generated by
// [coverparser.Parser].
func (r Result) Dir() string {
	return r.dir
}

// UUIDFunc for generating a UUID for a [Result].
//
// By default, [nanoid.New] is used for UUID generation, but function can be
// replaced for testing purposes.
type UUIDFunc func() (string, error)

// Option configures a [Runner].
type Option func(*Runner)

// Runner runs tests and parses the results.
type Runner struct {
	ctx           context.Context
	root          string
	logger        *log.Logger
	parser        *parser
	shuffle       string
	covermode     string
	raceDetection bool
	short         bool
	timeout       time.Duration
	goBin         string
	coverDir      string
	coverDirOnce  sync.Once
	runnerFunc    command.Runner
	uuidFunc      UUIDFunc
}

// New Runner for running tests.
//
// Runs `go test` on directories for Go source files and parses the output for
// easy consumption.
//
// The root directory should be the root directory of a Go project with tests.
func New(ctx context.Context, rootDir string, opts ...Option) *Runner {
	r := &Runner{
		ctx:        ctx,
		root:       rootDir,
		logger:     log.New(io.Discard),
		parser:     &parser{},
		covermode:  defaultCovermode,
		timeout:    defaultTimeout,
		goBin:      defaultGoBin,
		runnerFunc: command.DefaultRunner,
		uuidFunc:   nanoid.New,
	}

	for _, opt := range opts {
		opt(r)
	}

	r.parser.logger = r.logger

	return r
}

// Run tests for packages.
//
// Runs `go test` on given packages and parses the results.
func (r *Runner) Run(pkgs ...string) (*Result, error) {
	var (
		out []byte
		err error
	)

	result := &Result{
		Pass:  true,
		Start: time.Now(),
	}

	if result.UUID, err = r.uuidFunc(); err != nil {
		return nil, fmt.Errorf("generating UUID for test run result: %w", err)
	}

	if result.Targets, err = r.processTargets(pkgs); err != nil {
		return nil, err
	}

	if result.dir, err = r.mkdirCover(result.UUID); err != nil {
		return nil, err
	}

	r.logger.Info("running tests...")

	args := r.mkArgs(result)

	r.logger.Debug("command", "cmd", r.goBin, "args", strings.Join(args, " "))

	out, result.ExitCode, err = r.runnerFunc(r.ctx, r.root, r.goBin, args...)
	result.Duration = time.Since(result.Start)

	if err != nil || result.ExitCode != 0 {
		if err := r.handleError(err, out); err != nil {
			result.Error = err.Error()
			result.Pass = false

			return result, err
		}
	}

	r.logger.Debug("command finished", "dur", result.Duration, "exitCode", result.ExitCode)

	result.Packages, err = r.parser.parse(out)
	if err != nil {
		return nil, fmt.Errorf("parsing output of go test command: %w", err)
	}

	for _, pkg := range result.Packages {
		for _, test := range pkg.Tests {
			result.Tests++

			switch {
			case test.Pass:
				result.Passed++
			case test.Skip:
				result.Skipped++
			case !test.Pass:
				result.Failed++
			}
		}
	}

	if result.Failed != 0 {
		result.Pass = false
	}

	r.handleResult(result)

	return result, nil
}

func (r *Runner) PackageForFile(name string) (string, error) {
	args := []string{"list", "-find", "-f", "{{.ImportPath}}", filepath.Dir(name)}

	r.logger.Debug("command", "cmd", r.goBin, "args", strings.Join(args, " "))

	out, exitCode, err := r.runnerFunc(r.ctx, r.root, r.goBin, args...)
	if err != nil {
		return "", fmt.Errorf("running go list command: %w", err)
	}

	if exitCode != 0 {
		return "", fmt.Errorf("running go list command: exit code: %s", out)
	}

	return strings.TrimSpace(string(out)), nil
}

func (r *Runner) handleResult(result *Result) {
	logger := r.logger.With(
		"pass", result.Pass,
		"tests", result.Tests,
		"packages", len(result.Packages),
		"passed", result.Passed,
		"skipped", result.Skipped,
		"failed", result.Failed,
		"dur", result.Duration.Round(time.Millisecond),
	)

	switch {
	case result.Tests == 0:
		logger.Info("no tests found")
	case result.Pass:
		logger.Info("tests passed")
	default:
		logger.With("exitCode", result.ExitCode).Warn("tests failed")
	}
}

func (r *Runner) handleError(err error, out []byte) error {
	var reason string

	switch {
	case errors.Is(err, context.Canceled):
		reason = "canceled"
	case errors.Is(err, context.DeadlineExceeded):
		reason = "timeout"
	case errors.Is(err, exec.ErrNotFound):
		reason = fmt.Sprintf("go binary %q was not found", r.goBin)
	case bytes.Contains(out, []byte("panic: test timed out")):
		reason = "timeout"
	case bytes.Contains(out, []byte("[build failed]")):
		reason = "build failed"
	default:
		return nil
	}

	return fmt.Errorf(reason)
}

func (r *Runner) mkdirCover(uuid string) (string, error) {
	r.coverDirOnce.Do(func() {
		if r.coverDir == "" {
			var err error

			r.coverDir, err = os.MkdirTemp("", "gokiburi-coverage")
			if err != nil {
				panic(fmt.Errorf("creating temporary directory for test coverage files: %w", err))
			}
		}
	})

	name := filepath.Join(r.coverDir, uuid)

	if err := os.MkdirAll(name, coverDirPerm); err != nil {
		return "", fmt.Errorf("creating coverage dir %q: %w", name, err)
	}

	return name, nil
}

func (r *Runner) mkArgs(result *Result) []string {
	args := []string{
		"test", "-json", "-cover",
		"-coverprofile", path.Join(result.dir, "coverprofile.out"),
	}

	if r.shuffle != "" {
		args = append(args, "-shuffle", r.shuffle)
	}

	if r.raceDetection {
		args = append(args, "-race", "-covermode", "atomic")
	} else {
		args = append(args, "-covermode", r.covermode)
	}

	if r.short {
		args = append(args, "-short")
	}

	if r.timeout != 0 {
		args = append(args, "-timeout", r.timeout.String())
	}

	return append(args, result.Targets...)
}

func (r *Runner) processTargets(targets []string) ([]string, error) {
	targetMap := make(map[string]struct{})

	validPkgs, err := r.validPackages()
	if err != nil {
		return nil, fmt.Errorf("determining valid packages: %w", err)
	}

	for _, t := range targets {
		if _, ok := validPkgs[t]; ok {
			targetMap[t] = struct{}{}
			continue
		}

		r.logger.Warnf("invalid package: %q", t)
	}

	tt := make([]string, 0, len(targetMap))

	for t := range targetMap {
		tt = append(tt, t)
	}

	return tt, nil
}

func (r *Runner) validPackages() (map[string]struct{}, error) {
	pkgs := make(map[string]struct{})
	pkgs["./..."] = struct{}{}

	args := []string{"list", "./..."}

	r.logger.Debug("command", "cmd", r.goBin, "args", strings.Join(args, " "))

	out, exitCode, err := r.runnerFunc(r.ctx, r.root, r.goBin, args...)
	if err != nil {
		return nil, fmt.Errorf("running go list command: %w", err)
	}

	if exitCode != 0 {
		return nil, fmt.Errorf("running go list command: exit code %d", exitCode)
	}

	for _, pkg := range strings.Fields(string(out)) {
		pkgs[pkg] = struct{}{}
	}

	return pkgs, nil
}

// WithLogger configures [Runner] with a logger.
func WithLogger(logger *log.Logger) Option {
	return func(r *Runner) {
		r.logger = logger
	}
}

// WithGoBinPath configures [Runner] to use path as go binary for running tests.
//
// By default, `go` is used.
func WithGoBinPath(goBinPath string) Option {
	return func(r *Runner) {
		r.goBin = goBinPath
	}
}

// WithRunnerFunc configures [Runner] to use function for running commands.
//
// By default, commands are run with the `os/exec` package, but the runner
// function can be replaced for testing purposes.
func WithRunnerFunc(rf command.Runner) Option {
	return func(r *Runner) {
		r.runnerFunc = rf
	}
}

// WithUUIDFunc configures [Runner] to use function for UUID generation.
//
// By default, [nanoid.New] is used for UUID generation, but function can be
// replaced for testing purposes.
func WithUUIDFunc(uf UUIDFunc) Option {
	return func(r *Runner) {
		r.uuidFunc = uf
	}
}

// WithShuffle configures [Runner] to run tests with `-shuffle` flag.
func WithShuffle(val string) Option {
	return func(r *Runner) {
		r.shuffle = val
	}
}

// WithCovermode configures [Runner] to run tests with `-covermode` flag.
func WithCovermode(val string) Option {
	return func(r *Runner) {
		r.covermode = val
	}
}

// WithRaceDetection configures [Runner] to run tests with `-race` flag.
//
// Note: Enabling race detection will force the covermode to be `atomic`.
func WithRaceDetection(enabled bool) Option {
	return func(r *Runner) {
		r.raceDetection = enabled
	}
}

// WithShort configures [Runner] to run tests with `-short` flag.
func WithShort(enabled bool) Option {
	return func(r *Runner) {
		r.short = enabled
	}
}

// WithTimeout configures [Runner] to use duration for test run timeout.
func WithTimeout(dur time.Duration) Option {
	return func(r *Runner) {
		r.timeout = dur
	}
}
